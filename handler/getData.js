"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetCustomerAddress = void 0;
const AWS = require("aws-sdk");
const tableName = process.env.TABLE_NAME;
console.log("ðŸš€ ~ tableName:", tableName);
const documentClient = new AWS.DynamoDB.DocumentClient({
    region: process.env.region,
});
class GetCustomerAddress {
    constructor(userId, suburb, postcode) {
        this.userId = userId;
        this.suburb = suburb;
        this.postcode = postcode;
    }
    ;
    async getData() {
        let item;
        const params = {
            IndexName: 'UserIdIndex',
            KeyConditionExpression: 'UserId = :userId',
            ExpressionAttributeValues: {
                ':userId': this.userId,
            },
            TableName: tableName,
        };
        if (this.suburb) {
            params.FilterExpression = 'Suburb = :suburb';
            params.ExpressionAttributeValues[':suburb'] = this.suburb;
        }
        // Check if postcode parameter is provided and add it to the query
        if (this.postcode) {
            if (params.FilterExpression) {
                params.FilterExpression += ' AND PostCode = :postcode';
            }
            else {
                params.FilterExpression = 'PostCode = :postcode';
            }
            params.ExpressionAttributeValues[':postcode'] = this.postcode;
        }
        try {
            console.info('inside try', this.userId);
            const data = await documentClient.query(params).promise();
            item = data.Items;
            return item;
        }
        catch (e) {
            return {
                statusCode: 500,
                body: e === 500 ? 'Invalid Request Body' : e, // here we can create and import a commomn error function or specific error handling function where the out put can be organise 
            };
        }
    }
}
exports.GetCustomerAddress = GetCustomerAddress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0RGF0YS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImdldERhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0JBQThCO0FBRTlCLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDO0FBQ3pDLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEVBQUUsU0FBUyxDQUFDLENBQUE7QUFDekMsTUFBTSxjQUFjLEdBQUcsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQztJQUNyRCxNQUFNLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNO0NBQzNCLENBQUMsQ0FBQztBQUVILE1BQWEsa0JBQWtCO0lBSy9CLFlBQVksTUFBVyxFQUFFLE1BQVksRUFBRSxRQUFhO1FBQzVDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0lBQzdCLENBQUM7SUFBQSxDQUFDO0lBQ0MsS0FBSyxDQUFDLE9BQU87UUFDaEIsSUFBSSxJQUFJLENBQUM7UUFDVCxNQUFNLE1BQU0sR0FBdUM7WUFDM0MsU0FBUyxFQUFFLGFBQWE7WUFDeEIsc0JBQXNCLEVBQUUsa0JBQWtCO1lBQzFDLHlCQUF5QixFQUFFO2dCQUMzQixTQUFTLEVBQUUsSUFBSSxDQUFDLE1BQU07YUFDcEI7WUFDRixTQUFTLEVBQUUsU0FBVTtTQUN2QixDQUFDO1FBQ0YsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2hCLE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQztZQUM3QyxNQUFNLENBQUMseUJBQTBCLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUM1RDtRQUVELGtFQUFrRTtRQUNsRSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsSUFBSSxNQUFNLENBQUMsZ0JBQWdCLEVBQUU7Z0JBQzNCLE1BQU0sQ0FBQyxnQkFBZ0IsSUFBSSwyQkFBMkIsQ0FBQzthQUN4RDtpQkFBTTtnQkFDTCxNQUFNLENBQUMsZ0JBQWdCLEdBQUcsc0JBQXNCLENBQUM7YUFDbEQ7WUFDRCxNQUFNLENBQUMseUJBQTBCLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztTQUNoRTtRQUNELElBQUc7WUFDQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDeEMsTUFBTSxJQUFJLEdBQUcsTUFBTSxjQUFjLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzFELElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ2xCLE9BQU8sSUFBSSxDQUFDO1NBQ2Q7UUFBQSxPQUFNLENBQUMsRUFBQztZQUNOLE9BQU87Z0JBQ0gsVUFBVSxFQUFHLEdBQUc7Z0JBQ2hCLElBQUksRUFBRSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLGdJQUFnSTthQUMvSyxDQUFDO1NBQ047SUFDTixDQUFDO0NBQ0o7QUE5Q0QsZ0RBOENDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQVdTIGZyb20gXCJhd3Mtc2RrXCJcbmltcG9ydCB7IER5bmFtb0RCIH0gZnJvbSBcImF3cy1zZGtcIjtcbmNvbnN0IHRhYmxlTmFtZSA9IHByb2Nlc3MuZW52LlRBQkxFX05BTUU7XG5jb25zb2xlLmxvZyhcIvCfmoAgfiB0YWJsZU5hbWU6XCIsIHRhYmxlTmFtZSlcbmNvbnN0IGRvY3VtZW50Q2xpZW50ID0gbmV3IEFXUy5EeW5hbW9EQi5Eb2N1bWVudENsaWVudCh7XG4gIHJlZ2lvbjogcHJvY2Vzcy5lbnYucmVnaW9uLFxufSk7XG5cbmV4cG9ydCBjbGFzcyBHZXRDdXN0b21lckFkZHJlc3Mge1xucHVibGljIHVzZXJJZCA6IGFueTtcbnB1YmxpYyBzdWJ1cmIgOiBhbnk7XG5wdWJsaWMgcG9zdGNvZGUgOiBhbnk7XG4gICAgXG5jb25zdHJ1Y3Rvcih1c2VySWQ6IGFueSwgc3VidXJiIDogYW55LCBwb3N0Y29kZTogYW55KXtcbiAgICAgICAgdGhpcy51c2VySWQgPSB1c2VySWQ7XG4gICAgICAgIHRoaXMuc3VidXJiID0gc3VidXJiO1xuICAgICAgICB0aGlzLnBvc3Rjb2RlID0gcG9zdGNvZGU7XG4gICAgfTtcbnB1YmxpYyBhc3luYyBnZXREYXRhKCl7XG4gICAgbGV0IGl0ZW07XG4gICAgY29uc3QgcGFyYW1zOiBEeW5hbW9EQi5Eb2N1bWVudENsaWVudC5RdWVyeUlucHV0ID0ge1xuICAgICAgICAgICAgSW5kZXhOYW1lOiAnVXNlcklkSW5kZXgnLFxuICAgICAgICAgICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbjogJ1VzZXJJZCA9IDp1c2VySWQnLFxuICAgICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICAgICAgICAgJzp1c2VySWQnOiB0aGlzLnVzZXJJZCxcbiAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgVGFibGVOYW1lOiB0YWJsZU5hbWUhLFxuICAgICAgICAgfTtcbiAgICAgICAgIGlmICh0aGlzLnN1YnVyYikge1xuICAgICAgICAgIHBhcmFtcy5GaWx0ZXJFeHByZXNzaW9uID0gJ1N1YnVyYiA9IDpzdWJ1cmInO1xuICAgICAgICAgIHBhcmFtcy5FeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzIVsnOnN1YnVyYiddID0gdGhpcy5zdWJ1cmI7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgcG9zdGNvZGUgcGFyYW1ldGVyIGlzIHByb3ZpZGVkIGFuZCBhZGQgaXQgdG8gdGhlIHF1ZXJ5XG4gICAgICAgIGlmICh0aGlzLnBvc3Rjb2RlKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5GaWx0ZXJFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBwYXJhbXMuRmlsdGVyRXhwcmVzc2lvbiArPSAnIEFORCBQb3N0Q29kZSA9IDpwb3N0Y29kZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5GaWx0ZXJFeHByZXNzaW9uID0gJ1Bvc3RDb2RlID0gOnBvc3Rjb2RlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyYW1zLkV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXMhWyc6cG9zdGNvZGUnXSA9IHRoaXMucG9zdGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdpbnNpZGUgdHJ5JywgdGhpcy51c2VySWQpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGRvY3VtZW50Q2xpZW50LnF1ZXJ5KHBhcmFtcykucHJvbWlzZSgpO1xuICAgICAgICAgICAgaXRlbSA9IGRhdGEuSXRlbXM7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogIDUwMCxcbiAgICAgICAgICAgICAgICBib2R5OiBlID09PSA1MDAgPyAnSW52YWxpZCBSZXF1ZXN0IEJvZHknIDogZSwgLy8gaGVyZSB3ZSBjYW4gY3JlYXRlIGFuZCBpbXBvcnQgYSBjb21tb21uIGVycm9yIGZ1bmN0aW9uIG9yIHNwZWNpZmljIGVycm9yIGhhbmRsaW5nIGZ1bmN0aW9uIHdoZXJlIHRoZSBvdXQgcHV0IGNhbiBiZSBvcmdhbmlzZSBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4gICAgIl19